var documenterSearchIndex = {"docs":
[{"location":"semirings/#Semirings","page":"Semirings","title":"Semirings","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Algorithms implemented in this package are very generic as they can be applied on various type of \"numbers\":","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"probabilities (values between 0 and +infty)\nlog-probabilities (values between -infty and +infty)\n...","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Formally, they can operate on any semiring or semifield for some of them.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"To work with these algebraic structures, the package defines the following abstract types:","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Semiring\nSemifield","category":"page"},{"location":"semirings/#MarkovModels.Semirings.Semiring","page":"Semirings","title":"MarkovModels.Semirings.Semiring","text":"abstract type Semiring <: Number end\n\nAbstract base type for all semirings.\n\n\n\n\n\n","category":"type"},{"location":"semirings/#MarkovModels.Semirings.Semifield","page":"Semirings","title":"MarkovModels.Semirings.Semifield","text":"abstract type Semifield <: Semiring end\n\nAbstract base type for all semifields.\n\n\n\n\n\n","category":"type"},{"location":"semirings/#Concrete-types","page":"Semirings","title":"Concrete types","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The package provides the following concrete types:","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"LogSemifield\nProbabilitySemifield\nTropicalSemiring","category":"page"},{"location":"semirings/#MarkovModels.Semirings.LogSemifield","page":"Semirings","title":"MarkovModels.Semirings.LogSemifield","text":"struct LogSemifield{T<:AbstractFloat} <: Semfield\n    val::T\nend\n\nLog-semifield is defined as :\n\nx oplus y triangleq ln( e^x + e^y)\nx otimes y triangleq x + y\nx oslash y triangleq x - y\n\nforall x y in mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"semirings/#MarkovModels.Semirings.ProbabilitySemifield","page":"Semirings","title":"MarkovModels.Semirings.ProbabilitySemifield","text":"struct ProbabilitySemifield{T<:AbstractFloat} <: Semfield\n    val::T\nend\n\nLog-semifield is defined as :\n\nx oplus y triangleq x + y\nx otimes y triangleq x cdot y\nx oslash y triangleq fracxy\n\nforall x y in 0 1.\n\n\n\n\n\n","category":"type"},{"location":"semirings/#MarkovModels.Semirings.TropicalSemiring","page":"Semirings","title":"MarkovModels.Semirings.TropicalSemiring","text":"struct TropicalSemiring{T<:AbstractFloat} <: Semiring\n    val::T\nend\n\nLog-semifield is defined as :\n\nx oplus y triangleq textmax(x y)\nx otimes y triangleq x + y\n\nforall x y in mathbbR.\n\n\n\n\n\n","category":"type"},{"location":"fsm/#Finite-State-Machines","page":"Finite State Machines","title":"Finite State Machines","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"This package represents Markov chains as probabilistic a Finite State Machine (FSM).  Here is an example of FSM as used by the package:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: missing image)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The thick line node indicates the starting state whereas the double line node indicates the ending state.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"note: Note\nTo be able to visualize FSMs as in the example above when using IJulia or Pluto, make sure that the dot program (from graphviz) is available in your shell PATH variable. Also, you won't be able to visualize the FSM in the REPL.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Note that, contrary to standard FSM, our implementation puts the labels in the states rather than on the arcs. This is equivalent of a constrained Weighted Finite State Acceptor where all the incoming arcs of a given states share the same labels. We have made this choice to facilitate the interpretation of our FSMs as Markov chains.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"In the following, we present the tools provided by the package to manipulate such FSM. All the examples below assume that you have already imported the MarkovModels.jl package by doing using MarkovModels.","category":"page"},{"location":"fsm/#FSM-interface","page":"Finite State Machines","title":"FSM interface","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"All the FSMs are subtypes from the following abstract type:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"AbstractFSM","category":"page"},{"location":"fsm/#MarkovModels.FSMs.AbstractFSM","page":"Finite State Machines","title":"MarkovModels.FSMs.AbstractFSM","text":"abstract type AbstractFSM{T<:Semiring} end\n\nAbstract base type for all the FSMs.\n\n\n\n\n\n","category":"type"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"They support the following functions:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"states\narcs\nBase.length(::AbstractFSM)","category":"page"},{"location":"fsm/#MarkovModels.FSMs.states","page":"Finite State Machines","title":"MarkovModels.FSMs.states","text":"states(fsm)\n\nReturn an iterator over the states of the fsm.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.FSMs.arcs","page":"Finite State Machines","title":"MarkovModels.FSMs.arcs","text":"arcs(fsm, state)\n\nReturn all arcs leaving state.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Base.length-Tuple{AbstractFSM}","page":"Finite State Machines","title":"Base.length","text":"length(fsm)\n\nReturn the number of states in the FSM.\n\n\n\n\n\n","category":"method"},{"location":"fsm/#Mutable-FSM-interface","page":"Finite State Machines","title":"Mutable FSM interface","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"FSM that can be changed in place (e.g. adding states/arcs) are subtypes of the following abstract type:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"AbstractMutableFSM","category":"page"},{"location":"fsm/#MarkovModels.FSMs.AbstractMutableFSM","page":"Finite State Machines","title":"MarkovModels.FSMs.AbstractMutableFSM","text":"abstract type AbstractFSM{T<:Semiring} end\n\nAbstract base type for FSM objects that can be mutated.\n\n\n\n\n\n","category":"type"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"They support the following functions:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"addstate!\naddarc!","category":"page"},{"location":"fsm/#MarkovModels.FSMs.addstate!","page":"Finite State Machines","title":"MarkovModels.FSMs.addstate!","text":"addstate!(fsm::AbstractMutableFSM{T}, label; initweight = zero(T),\n          finalweight = zero(T))\n\nCreate a state and add it to fsm.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.FSMs.addarc!","page":"Finite State Machines","title":"MarkovModels.FSMs.addarc!","text":"addarc!(fsm::AbstractFSM, src, dest, weight)\n\nAdd a directed weighted arc from state src to state dest with weight weight.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Concrete-FSMs","page":"Finite State Machines","title":"Concrete FSMs","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The package has the following concrete FSM types:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"VectorFSM\nHierarchicalFSM\nMatrixFSM","category":"page"},{"location":"fsm/#MarkovModels.FSMs.VectorFSM","page":"Finite State Machines","title":"MarkovModels.FSMs.VectorFSM","text":"struct VectorFSM{T} <: AbstractMutableFSM{T}\n    states::Vector{State{T}}\n    arcs::Dict{State, Vector{Arc{T}}}\nend\n\nMutable FSM that store the states and arcs into vectors.\n\n\n\n\n\n","category":"type"},{"location":"fsm/#MarkovModels.FSMs.HierarchicalFSM","page":"Finite State Machines","title":"MarkovModels.FSMs.HierarchicalFSM","text":"struct HierarchicalFSM{T} <: AbstractFSM{T}\n    fsm::AbstractFSM{T}\n    state_mapping::Dict{Any,<:AbstractFSM{T}}\nend\n\nFSM where each state is an FSM. This FSM is used to \"compose\" different FSMs, e.g. a lexicon and a language model.\n\n\n\n\n\n","category":"type"},{"location":"fsm/#MarkovModels.FSMs.MatrixFSM","page":"Finite State Machines","title":"MarkovModels.FSMs.MatrixFSM","text":"struct MatrixFSM{T<:Semiring}\n    π        # vector of initial probabilities\n    T        # matrix of transition probabilities\n    Tᵀ       # transpose of `T`\n    C        # matrix mapping state -> pdfindex\n    Cᵀ       # tranpose of `C`\n    labels   # vector of labels (label can be `String`, `Tuple`, etc.)\nend\n\nFSM where the arcs are stored as a sparse matrix. This type of FSM is used by the inference algorigthms. In addition to the structure of the FSM, the MatrixFSM store the mapping between states and pdf-id in the matrix C.\n\nwarning: Warning\nIn this format, the final state is just a \"regular\" state. Therefore, the dimension of π (similarly for T and C) will have one more dimension.\n\nConstructor\n\nMatrixFSM(fsm, pdfid_mapping)\n\n\n\n\n\n","category":"type"},{"location":"fsm/#FSM-operations","page":"Finite State Machines","title":"FSM operations","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Base.union(::AbstractFSM{T}, ::AbstractFSM{T}) where T\ndeterminize\nminimize\nrenormalize\ntranspose","category":"page"},{"location":"fsm/#Base.union-Union{Tuple{T}, Tuple{AbstractFSM{T}, AbstractFSM{T}}} where T","page":"Finite State Machines","title":"Base.union","text":"Base.union(f::AbstractFMS{T}...)\n\nTake the union of the provided FSMs.\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.FSMs.determinize","page":"Finite State Machines","title":"MarkovModels.FSMs.determinize","text":"determinize(fsm::AbstractFSM)\n\nDeterminize the FSM w.r.t. the state labels. A FSM is deterministic if for any state there is no next states with the same label.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.FSMs.minimize","page":"Finite State Machines","title":"MarkovModels.FSMs.minimize","text":"minimize(fsm::AbstractFSM)\n\nReturn a minimal equivalent fsm.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.FSMs.renormalize","page":"Finite State Machines","title":"MarkovModels.FSMs.renormalize","text":"renormalize(fsm::AbstractFSM{T}) where T<:Semifield\n\nEnsure the that the weights of all the outgoing arcs leaving a state sum up to one(T).\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Base.transpose","page":"Finite State Machines","title":"Base.transpose","text":"transpose(fsm::AbstractFSM)\n\nReverse the direction of the arcs and, for each state, inverse the initial and final weight.\n\n\n\n\n\n","category":"function"},{"location":"#MarkovModels-Documentation","page":"Home","title":"MarkovModels Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MarkovModels is a Julia package for probabilitistic inference in (Hidden) Markov Models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the project on github.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lucas Ondel\nMartin Kocour","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MarkovModels","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"semirings.md\", \"fsm.md\", \"inference.md\"]","category":"page"},{"location":"inference/#Inference","page":"Inference","title":"Inference","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"pdfposteriors\nmaxstateposteriors\nbestpath","category":"page"},{"location":"inference/#MarkovModels.Inference.pdfposteriors","page":"Inference","title":"MarkovModels.Inference.pdfposteriors","text":"pdfposteriors(mfsm::MatrixFSM{SF} lhs) where SF <: Semifield\npdfposteriors(union(mfsm1, mfsm2, ...), batch_lhs)\n\nCalculate the conditional posterior of \"assigning\" the nth frame to the ith pdf. The output is a tuple γ, ttl where γ is a matrix (# pdf x # frames) and ttl is the total probability of the sequence. This function can also be called in \"batch-mode\" by providing a union of compiled fsm and a 3D tensor containing the per-pdf, per-frame and per-batch values.\n\n\n\n\n\n","category":"function"},{"location":"inference/#MarkovModels.Inference.maxstateposteriors","page":"Inference","title":"MarkovModels.Inference.maxstateposteriors","text":"maxstateposteriors(mfsm, lhs)\n\nCalculate the posterior of \"assigning\" the nth frame to the ith state conditioned on all other states maximizing the likelihood of the sequence. The output is a matrix μ (# pdf x # frames).\n\n\n\n\n\n","category":"function"},{"location":"inference/#MarkovModels.Inference.bestpath","page":"Inference","title":"MarkovModels.Inference.bestpath","text":"bestpath(mfsm, μ)\n\nReturn the sequence of state with the highest value from μ, where μ is the ouput of maxstateposteriors.\n\n\n\n\n\n","category":"function"}]
}
